<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# // To debug, uncomment the next two lines !! 
//System.Diagnostics.Debugger.Launch();
//System.Diagnostics.Debugger.Break();
#>
<#PrepareDataToRender(this); #>
<#var manager = Manager.Create(Host, GenerationEnvironment); #>
<#manager.StartHeader(); #>// <auto-generated />
#pragma warning disable 1591
#region T4Decorator

using System;
using System.Diagnostics;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

<#foreach (var decorator in GetDecorators().Where(d => d.IsTracingDecorator == false)) { #>
<#manager.StartNewFile(decorator.GeneratedFileName); #>
namespace <#=decorator.Namespace #>
{
    [<#= GeneratedCode #>, DebuggerNonUserCode]
    <#= decorator.AccessModifier #> partial class <#=decorator.ClassName #>
    {
<#foreach (var target in decorator.DecorationTargets) { #>
<#foreach (var property in target.Properties.Where(p => !p.IsIndexer)) { #>
        public <#= property.ReturnType #> <#= property.Name #>
        {
<# if (property.HasGetter) { #>
            get { return <#= target.AccessExpression #>.<#= property.Name #>; }
<#
}
if (property.HasSetter) { #>
            set { <#= target.AccessExpression #>.<#= property.Name #> = value; }
<# } #>
        }

<#} /* end:property */#>
<#foreach (var method in target.Methods) { #>
<#if (method.ReturnType != "void") { #>
        public <#= method.ReturnType #> <#= method.Name #>(<# method.WriteFormalParameters(true); #>)
        {
            return <#= target.AccessExpression #>.<#= method.Name #>(<# method.WriteFormalParametersForInvoke(true); #>);
        }

<# } else { #>
        public void <#= method.Name #>(<# method.WriteFormalParameters(true); #>)
        {
            <#= target.AccessExpression #>.<#= method.Name #>(<# method.WriteFormalParametersForInvoke(true); #>);
        }

<# } /* void */ } /* end:method */ } /* end:target */#>
    }
}
<#manager.EndBlock(); #>
<#} #>


<#foreach (var decorator in GetDecorators().Where(d => d.IsTracingDecorator == true)) { #>
<#manager.StartNewFile(decorator.GeneratedFileName); #>
namespace <#=decorator.Namespace #>
{
    [<#= GeneratedCode #>, DebuggerNonUserCode]
    <#= decorator.AccessModifier #> partial class <#=decorator.ClassName #> : <#= T4Namespace #>.Generated.ITracingContextFactory
    {

<#foreach (var target in decorator.DecorationTargets) { #>
<#foreach (var property in target.Properties.Where(p => !p.IsIndexer)) { #>
        public <#= property.ReturnType #> <#= property.Name #>
        {
<# if (property.HasGetter) { #>
            get
            {
                using (this.CreateTracingContext("<#= decorator.ClassName #>.<#= property.Name #>(Getter)"))
                {
                    return <#= target.AccessExpression #>.<#= property.Name #>;
                }
            }
<#
}
if (property.HasSetter) { #>
            set
            {
                using (this.CreateTracingContext("<#= decorator.ClassName #>.<#= property.Name #>(Setter)"))
                {
                    <#= target.AccessExpression #>.<#= property.Name #> = value;
                }
            }
<# } #>
        }

<#} /* end:property */#>
<#foreach (var method in target.Methods) { #>
        public <#= method.ReturnType #> <#= method.Name #>(<# method.WriteFormalParameters(true); #>)
        {
            using (this.CreateTracingConext("<#= decorator.ClassName #>.<#= method.Name #>(<# method.WriteFormalParametersForInvoke(true); #>)"))
            {
                return <#= target.AccessExpression #>.<#= method.Name #>(<# method.WriteFormalParametersForInvoke(true); #>);
            }
        }

<#}}#>
    }
}
<#manager.EndBlock(); #>
<#} #>

namespace <#= T4Namespace #>.Generated
{
    internal interface ITracingContextFactory
    {
        IDisposable CreateTracingConext(string name);
    }
}

<#manager.StartFooter(); #>
#endregion T4Decorator
#pragma warning restore 1591
<#manager.EndBlock(); #>
<#manager.Process(true); #>

<#+
const string DecoratorSuffix = "Decorator";
const string GeneratedCode = @"GeneratedCode(""T4Decorator"", ""1.0"")";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Globals
static TextTransformation TT;
static DTE Dte;
static Project Project;
static HashSet<AreaInfo> Areas;
static string T4Folder;
static string T4FileName;
static string AppRoot;
static string T4Namespace;
static Microsoft.CSharp.CSharpCodeProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IEnumerable<DecoratorInfo> GetDecorators()
{
    var decorators = new List<DecoratorInfo>();

    foreach (var area in Areas)
    {
        decorators.AddRange(area.GetDecorators());
    }

    return decorators;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Initialize rendering context
void PrepareDataToRender(TextTransformation tt)
{
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    Areas = new HashSet<AreaInfo>();

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
    {
        Dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null)
    {
        throw new Exception("T4MVC can only execute through the Visual Studio host.");
    }

    Project = GetProjectContainingT4File(Dte);
    if (Project == null)
    {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    // Get the path of the root folder of the application
    AppRoot = Path.GetDirectoryName(Project.FullName) + '\\';

    // Get the project global name space
    T4Namespace = Project.Properties.Item("DefaultNamespace").Value.ToString();

    // Process decorators and views from project root
    ProcessProjectRoot(Project);
}

Project GetProjectContainingT4File(DTE dte)
{

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(EnvDTE.Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

void ProcessProjectRoot(Project project)
{
    var area = new AreaInfo() { Name = null };

    // process decorators and views from their folders
    ProcessDecorators(project.ProjectItems, area);

    Areas.Add(area);
}

void ProcessDecorators(ProjectItems areaFolderItems, AreaInfo area)
{
    foreach(ProjectItem projectItem in areaFolderItems)
    {
        // Every folder might contain a decorator.
        ProcessDecoratorsRecursive(projectItem, area);
    }
}

void ProcessDecoratorsRecursive(ProjectItem projectItem, AreaInfo area)
{
    // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
    foreach (ProjectItem item in projectItem.ProjectItems)
    {
        ProcessDecoratorsRecursive(item, area);
    }

    if (projectItem.FileCodeModel != null)
    {
        DateTime controllerLastWriteTime = File.GetLastWriteTime(projectItem.get_FileNames(0));
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>())
        {
            ProcessDecoratorType(type, area, controllerLastWriteTime);
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>())
        {
            foreach (var type in ns.Members.OfType<CodeClass2>())
            {
                ProcessDecoratorType(type, area, controllerLastWriteTime);
            }
        }
    }
}

void ProcessDecoratorType(CodeClass2 type, AreaInfo area, DateTime controllerLastWriteTime)
{
    // Only process decorators
    if (!IsDecorator(type))
    {
        return;
    }

    // Collect misc info about the decorator class and add it to the collection
    var decoratorInfo = new DecoratorInfo
    {
        Area = area,
        Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
        ClassName = type.Name,
        AccessModifier = type.Access == vsCMAccess.vsCMAccessProject ? "internal" : "public",
    };

    // Make sure the class is partial
    if (!type.IsAbstract && type.ClassKind != vsCMClassKind.vsCMClassKindPartialClass)
    {
        try
        {
            type.ClassKind = vsCMClassKind.vsCMClassKindPartialClass;
        }
        catch
        {
            // If we couldn't make it partial, give a warning and skip it
            Warning(
                String.Format(
                    "{0} was not able to make the class {1} partial. Please change it manually if possible", 
                    T4FileName, 
                    type.Name));
            return;
        }
        Warning(String.Format("{0} changed the class {1} to be partial", T4FileName, type.Name));
    }

    // Check if the controller has changed since the generated file was last created
    DateTime lastGenerationTime = File.GetLastWriteTime(decoratorInfo.GeneratedFileFullPath);
    if (lastGenerationTime > controllerLastWriteTime)
    {
        decoratorInfo.GeneratedCodeIsUpToDate = true;
    }

    // Either process new DecoratorInfo or integrate results into existing object for partially defined classes
    var target = area.Decorators.Add(decoratorInfo) ? decoratorInfo : area.Decorators.First(c => c.Equals(decoratorInfo));

    if (type.IsAbstract)
    {
        // If it's abstract, set a flag and don't process methods (derived classes will)
        target.IsAbstract = true;
    }
    else
    {
        // Process private and public members, potential decoration targets
        ProcessDecorationTargets(target, type);
    }
}

void ProcessDecorationTargets(DecoratorInfo decoratorInfo, CodeClass2 current)
{
    //var bases = current.Bases.OfType<CodeClass2>();
    var interfaces = current.ImplementedInterfaces.OfType<CodeInterface2>();

    // Fields that have the same type as an implemented interface are a decoration targets.
    decoratorInfo.DecorationTargets = 
        (from target in GetFields(current)
         where interfaces.Where(i => i.FullName == target.Type.AsFullName).Any()
         select new DecorationTargetInfo(current, (CodeTypeRef2)target.Type, GetAccessExpression(target, current.Name))).ToArray();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ProjectItem GetProjectItem(Project project, string name)
{
    return GetProjectItem(project.ProjectItems, name);
}

ProjectItem GetProjectItem(ProjectItems items, string subPath)
{

    ProjectItem current = null;
    foreach (string name in subPath.Split('\\'))
    {
        try
        {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch
        {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }

    return current;
}

static bool IsDecorator(CodeClass2 type)
{
    // Ignore any class which name doesn't end with "Decorator"
    // Ignore generated decorator files as well.
    return type.FullName.EndsWith(DecoratorSuffix)
        && !type.ProjectItem.Name.EndsWith(".generated.cs");
}

static string ProcessAreaOrDecoratorName(string name)
{
    return name;
}

// Get access expression
static string GetAccessExpression(CodeVariable2 variable, string declaringType)
{
    if (variable.IsShared)
    {
        return string.Format("{0}.{1}", declaringType, variable.Name);
    }
    else
    {
        return string.Format("this.{0}", variable.Name);
    }

}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeVariable2> GetFields(CodeClass2 codeClass)
{
    // Get fields defined by the class.
    return codeClass.Members.OfType<CodeVariable2>();
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeProperty2> GetProperties(CodeInterface2 codeClass)
{
    // Get fields defined by the class.
    return codeClass.Members.OfType<CodeProperty2>();
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass)
{
    // Only look at regular method (e.g. ignore things like contructors)
    return codeClass.Members.OfType<CodeFunction2>()
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionFunction);
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetConstructors(CodeClass2 codeClass)
{
    // Only look at regular method (e.g. ignore things like contructors)
    return codeClass.Members.OfType<CodeFunction2>()
        .Where(f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
}

// Return all the CodeFunction2 in the CodeElements collection
static IEnumerable<CodeFunction2> GetMethods(CodeInterface2 codeInterface)
{
    // Only look at regular methods
    return codeInterface.Members.OfType<CodeFunction2>();
}

// Check if the class has any explicit constructor
static bool HasExplicitConstructor(CodeClass2 codeClass)
{
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => !f.IsShared && f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
}

// Check if the class has a default (i.e. no params) constructor
static bool HasExplicitDefaultConstructor(CodeClass2 codeClass)
{
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => !f.IsShared && f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
}

// Find a method with a given name
static CodeFunction2 GetMethod(CodeClass2 codeClass, string name)
{
    return GetMethods(codeClass).FirstOrDefault(f => f.Name == name);
}

// Find an attribute of a given type on an attribute collection
static CodeAttribute2 GetAttribute(CodeElements attributes, string attributeType)
{
    for (int i = 1; i <= attributes.Count; i++)
    {
        try
        {
            var attrib = (CodeAttribute2)attributes.Item(i);
            if (attributeType.Split(',').Contains(attrib.FullName, StringComparer.OrdinalIgnoreCase))
            {
                return attrib;
            }
        }
        catch
        {
            // FullName can throw in some cases, so just ignore those attributes
            continue;
        }
    }
    return null;
}

static CodeAttribute2 GetAttribute(CodeClass2 type, string attributeType)
{
    while(type != null) {
        var attribute = GetAttribute(type.Attributes, attributeType);
        if(attribute != null)
            return attribute;
        if (type.Bases.Count == 0)
            return null;
        type = (CodeClass2)type.Bases.Item(1);
    }
    return null;
}

static string UniqueFullName(CodeTypeRef codeType)
{
    return UniqueFullName(codeType.CodeType);
}

static string UniqueFullName(CodeType codeType)
{
    var uniqueName = codeType.FullName;

    // Match characters not allowed in class names.
    uniqueName = Regex.Replace(uniqueName, @"[^\p{Ll}\p{Lu}\p{Lt}\p{Lm}\p{Lo}\p{Nl}\d]", "_");

    // Remove duplicate '_' characters
    uniqueName = Regex.Replace(uniqueName, @"__+", "_");

    // Remove trailing '_' characters
    uniqueName = uniqueName.TrimEnd('_');

    return uniqueName;
}

// Return whether a ProjectItem is a folder and not a file
static bool IsFolder(ProjectItem item)
{
    return (item.Kind == EnvDTE.Constants.vsProjectItemKindPhysicalFolder);
}

static string MakeClassName(string ns, string classname)
{
    return String.IsNullOrEmpty(ns) ? classname :
        String.IsNullOrEmpty(classname) ? ns : ns + "." + codeProvider.CreateEscapedIdentifier(classname);
}

static string SanitizeWithNoConflicts(string token, HashSet<string> names)
{
    string name = Sanitize(token);

    while (names.Contains(name))
    {
        name += "_";
    }

    names.Add(name);

    return name;
}

static string Sanitize(string token)
{
    if (token == null) return null;

    // Replace all invalid chars by underscores
    token = Regex.Replace(token, @"[\W\b]", "_", RegexOptions.IgnoreCase);

    // If it starts with a digit, prefix it with an underscore
    token = Regex.Replace(token, @"^\d", @"_$0");

    // Check for reserved words
    // TODO: Clean this up and add other reserved words (keywords, etc)
    if (token == "Url") token = "_Url";

    return token;
}

static string EscapeID(string id)
{
    return codeProvider.CreateEscapedIdentifier(id);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data structure to collect data about an area
class AreaInfo
{
    public AreaInfo()
    {
        Decorators = new HashSet<DecoratorInfo>();
    }

    public string Name { get; set; }
    public HashSet<DecoratorInfo> Decorators { get; set; }
    public bool IsFeatureFolderArea { get; set; }

    public string Namespace { get { return Name; } }

    public IEnumerable<DecoratorInfo> GetDecorators()
    {
        return Decorators.Where(c => !c.IsAbstract);
    }

    public IEnumerable<DecoratorInfo> GetAbstractDecorators()
    {
        return Decorators.Where(c => c.IsAbstract);
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data structure to collect data about a decorator class
class DecoratorInfo
{
    public DecoratorInfo()
    {
    }

    public AreaInfo Area { get; set; }
    public bool IsAbstract { get; set; }
    public bool GeneratedCodeIsUpToDate { get; set; }
    public string ClassName { get; set; }
    public string Namespace { get; set; }
    public ICollection<DecorationTargetInfo> DecorationTargets { get; set; }
    public string AccessModifier { get; set; }

    public string Name
    {
        get
        {
            // Trim the suffix
            return ClassName.Substring(0, ClassName.Length - DecoratorSuffix.Length);
        }
    }

    public string FullClassName
    {
        get
        {
            return MakeClassName(Namespace, ClassName);
        }
    }

    public string GeneratedFileName
    {
        get
        {
            return MakeClassName(this.Namespace, this.ClassName + ".generated.cs");
        }
    }

    public string GeneratedFileFullPath
    {
        get
        {
            return Path.Combine(T4Folder, GeneratedFileName);
        }
    }

    public bool IsTracingDecorator
    {
        get
        {
            return this.ClassName.EndsWith("TracingDecorator");
        }
    }

    class ActionComparer : IEqualityComparer<ActionMethodInfo>
    {
        public bool Equals(ActionMethodInfo x, ActionMethodInfo y)
        {
            return x.ActionName == y.ActionName;
        }

        public int GetHashCode(ActionMethodInfo obj)
        {
            return obj.ActionName.GetHashCode();
        }
    }

    class ActionParameterComparer : IEqualityComparer<MethodParamInfo>
    {
        public bool Equals(MethodParamInfo x, MethodParamInfo y)
        {
            return x.Name == y.Name;
        }

        public int GetHashCode(MethodParamInfo obj){
            return obj.Name.GetHashCode();
        }
    }

    public override string ToString()
    {
        return Name;
    }

    public override bool Equals(object obj)
    {
        return obj != null && FullClassName == ((DecoratorInfo)obj).FullClassName;
    }

    public override int GetHashCode()
    {
        return FullClassName.GetHashCode();
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data structure to collect data about a method
class FunctionInfo
{
    protected CodeFunction2 _method;
    private string _signature;

    public FunctionInfo(CodeFunction2 method)
    {
        Parameters = new List<MethodParamInfo>();

        // Can be null when an custom ActionResult has no ctor
        if (method == null)
            return;

        _method = method;

        // Build a unique signature for the method, used to avoid duplication
        _signature = method.Name;

        CanBeCalledWithoutParameters = true;

        // Process all the parameters
        foreach (var p in method.Parameters.OfType<CodeParameter2>())
        {
            // If any param is not optional, then the method can't be called without parameters
            if (p.ParameterKind != vsCMParameterKind.vsCMParameterKindOptional)
            {
                CanBeCalledWithoutParameters = false;
            }

            Parameters.Add(
                new MethodParamInfo()
                {
                    Name = p.Name,
                    Type = p.Type.AsString,
                    DefaultValue = p.DefaultValue,
                    IsOutParameter = p.ParameterKind == vsCMParameterKind.vsCMParameterKindOut,
                    IsRefParameter = p.ParameterKind == vsCMParameterKind.vsCMParameterKindRef,
                    IsParamsParapmeter = p.ParameterKind == vsCMParameterKind.vsCMParameterKindParamArray
                });
            _signature += "," + p.Type.AsString;
        }
    }

    protected virtual CodeTypeRef ReturnTypeImpl { get { return _method.Type; } }

    public string Name { get { return _method.Name; } }
    public string ReturnType { get { return ReturnTypeImpl.AsString; } }
    public string ReturnTypeFullName { get { return ReturnTypeImpl.AsFullName; } }
    public bool IsPublic { get { return _method.Access == vsCMAccess.vsCMAccessPublic; } }
    public List<MethodParamInfo> Parameters { get; private set; }
    public bool CanBeCalledWithoutParameters { get; private set; }

    // Write out all the parameters as part of a method declaration
    public void WriteFormalParameters(bool first, bool includeDefaults = false)
    {
        foreach (var p in Parameters)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                TT.Write(", ");
            }

            if (p.IsOutParameter) TT.Write("out ");
            if (p.IsRefParameter) TT.Write("ref ");
            if (p.IsParamsParapmeter) TT.Write("params ");

            TT.Write(p.Type + " " + p.Name);
            if(includeDefaults && !string.IsNullOrEmpty(p.DefaultValue))
            {
                TT.Write(" = " + p.DefaultValue);
            }
        }
    }

    // Write out all the parameters as part of a method declaration
    public void WriteFormalParametersForInvoke(bool first)
    {
        foreach (var p in Parameters)
        {
            if (first)
                first = false;
            else
                TT.Write(", ");

            if (p.IsOutParameter) TT.Write("out ");
            if (p.IsRefParameter) TT.Write("ref ");

            TT.Write(p.Name);
        }
    }

    // Pass non-empty param values to make sure the ActionResult ctors don't complain
    // REVIEW: this is a bit dirty
    public void WriteNonEmptyParameterValues(bool first)
    {
        foreach (var p in Parameters)
        {
            if (first)
                first = false;
            else
                TT.Write(", ");

            if(!string.IsNullOrEmpty(p.DefaultValue))
                TT.Write(p.DefaultValue);
            else
            {
                switch (p.Type)
                {
                    case "string":
                        TT.Write("\" \"");
                        break;
                    case "byte[]":
                        TT.Write("new byte[0]");
                        break;
                    default:
                        TT.Write("default(" + p.Type + ")");
                        break;
                }
            }
        }
    }

    public override bool Equals(object obj)
    {
        return obj != null && _signature == ((FunctionInfo)obj)._signature;
    }

    public override int GetHashCode()
    {
        return _signature.GetHashCode();
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class PropertyInfo
{
    private readonly CodeProperty2 property;

    public PropertyInfo(CodeProperty2 property)
    {
        if (property == null)
        {
            throw new ArgumentNullException("property");
        }

        this.property = property;
    }

    #region CodeProperty2 derived properties
    public string Name { get { return this.property.Name; } }
    public string ReturnType { get { return this.property.Type.AsString; } }
    public bool HasGetter { get { return this.property.ReadWrite != vsCMPropertyKind.vsCMPropertyKindWriteOnly; } }
    public bool HasSetter { get { return this.property.ReadWrite != vsCMPropertyKind.vsCMPropertyKindReadOnly; } }
    public bool IsIndexer { get { return this.property.Parameters.Count > 0; } }
    #endregion

    #region Equals implementation for use with Lynq
    public override bool Equals(object obj)
    {
        return obj != null && this.property.Name == ((PropertyInfo)obj).property.Name;
    }

    public override int GetHashCode()
    {
        return this.property.GetHashCode();
    }
    #endregion
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class MethodParamInfo
{
    public string Name { get; set; }
    public string Type { get; set; }
    public string DefaultValue { get; set; }
    public bool IsOutParameter { get; set; }
    public bool IsRefParameter { get; set; }
    public bool IsParamsParapmeter { get; set; }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data structure to collect data about decorated method
class ActionMethodInfo : FunctionInfo
{
    public ActionMethodInfo(CodeFunction2 method, CodeClass2 decorator, CodeTypeRef asyncType = null)
        : base(method)
    {
        if(asyncType != null) 
        {
            // Remove the Async from the end of the name to match the actual Action routing would use.
            // This also separates the Action Calls from the implementation
            _actionName = method.Name.Remove(method.Name.Length - 5);
            _returnType = asyncType;
        }
    }

    string _actionName;
    CodeTypeRef _returnType;

    protected override CodeTypeRef ReturnTypeImpl { get { return _returnType ?? base.ReturnTypeImpl; } }
    public string ActionName { get { return _actionName ?? base.Name; } }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Data structure to collect data about a field or property that holds a reference to a decoration target.
class DecorationTargetInfo
{
    private readonly List<FunctionInfo> methods;
    private readonly ICollection<FunctionInfo> implementedMethods;
    private readonly List<PropertyInfo> properties;
    private readonly ICollection<PropertyInfo> implementedProperties;
    private readonly string accessExpression;
    private readonly CodeClass2 implementation;

    public DecorationTargetInfo(CodeClass2 implementation, CodeTypeRef2 source, string target)
    {
        this.methods = new List<FunctionInfo>();
        this.properties = new List<PropertyInfo>();
        this.implementedMethods = GetMethods(implementation).Select(f => new FunctionInfo(f)).ToArray();
        this.implementedProperties = implementation.Members.OfType<CodeProperty2>().Select(p => new PropertyInfo(p)).ToArray();

        if (source.CodeType.Kind == vsCMElement.vsCMElementInterface)
        {
            // Get all interfaces we need to implement by walking the inheritance hierarchy
            var interfaces = this.ProcessInterfaces((CodeInterface2)source.CodeType);

            foreach(var targetInterface in interfaces)
            {
                // Type may have multiple parts i.e.its a partial interface/class
                // look through all parts for not yet implemented members.
                var parts = targetInterface.Parts.OfType<CodeType>();
                this.methods.AddRange(this.ProcessDecoratorInterfacesMethods(parts));
                this.properties.AddRange(this.ProcessDecoratorInterfaceProperties(parts));
            }
        }

        this.accessExpression = target;
        this.implementation = implementation;
    }

    public string AccessExpression { get { return this.accessExpression; } }
    public ICollection<FunctionInfo> Methods { get { return this.methods; } }
    public ICollection<PropertyInfo> Properties { get { return this.properties; } }

    private IEnumerable<CodeInterface2> ProcessInterfaces(CodeInterface2 type)
    {
        // Get all base interfaces as well as one passed in.
        // At the least current interface will be returned.
        return
            (from super in type.Bases.OfType<CodeType>()
             select (CodeInterface2)this.ResolveCodeType(super)).Concat(new [] { (CodeInterface2)this.ResolveCodeType((CodeType)type) });
    }

    private ICollection<FunctionInfo> ProcessDecoratorInterfacesMethods(IEnumerable<CodeType> parts)
    {
        var functions = new List<FunctionInfo>();

        // Use original type and other parts to build up collection of
        // properties not yet implemented.
        foreach (var typePart in parts)
        {
            // Resolve type to the declaring project to enable full functionality
            var type = ResolveCodeType(typePart);

        // Ignore non-public and already implemented methods.
        functions.AddRange(
            (from method in type.Members.OfType<CodeFunction2>()
             where method.Access == vsCMAccess.vsCMAccessPublic
             select new FunctionInfo(method)).Where(m => !this.implementedMethods.Contains(m)));
        }

        return functions;
    }

    private ICollection<PropertyInfo> ProcessDecoratorInterfaceProperties(IEnumerable<CodeType> parts)
    {
        var props = new List<PropertyInfo>();

        // Use original type and other parts to build up collection of
        // properties not yet implemented.
        foreach (var typePart in parts)
        {
            // Resolve type to the declaring project to enable full functionality
            var type = ResolveCodeType(typePart);

            props.AddRange(
                (from prop in type.Members.OfType<CodeProperty2>()
                 where prop.Access == vsCMAccess.vsCMAccessPublic
                 select new PropertyInfo(prop)).Where(p => !this.implementedProperties.Contains(p)));
        }

        return props;
    }

    private CodeType ResolveCodeType(CodeType type)
    {
        // If the type doesn't come from this project, some actions on it will fail.
        // Try to get a real project type if possible.
        if (type.InfoLocation != vsCMInfoLocation.vsCMInfoLocationProject)
        {
            // Go through all the projects in the solution
            for (int i = 1; i <= Dte.Solution.Projects.Count; i++)
            {
                Project prj = null;
                try
                {
                    prj = Dte.Solution.Projects.Item(i);
                }
                catch (System.Runtime.Serialization.SerializationException)
                {
                    // Some project types (that we don't care about) cause a strange exception, so ingore it
                    continue;
                }

                // Skip it if it's the current project or doesn't have a code model
                try
                {
                    if (prj == Project || prj.CodeModel == null)
                        continue;
                }
                catch (System.NotImplementedException)
                {
                    // Installer project does not implement CodeModel property
                    continue;
                }

                try
                {
                    // If we can get a local project type, use it instead of the original
                    var codeType = prj.CodeModel.CodeTypeFromFullName(type.FullName);
                    if (codeType != null && codeType.InfoLocation == vsCMInfoLocation.vsCMInfoLocationProject)
                    {
                        type = codeType;
                        break;
                    }
                }
                catch (System.ArgumentException)
                {
                    // CodeTypeFromFullName throws when called on VB projects with a type it doesn't know
                    // (instead of returning null), so ignore those exceptions (See http://t4mvc.codeplex.com/workitem/7)
                }
            }
        }

        return type;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/

// Manager class records the various blocks so it can split them up
class Manager
{
    private class Block
    {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
    {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public virtual bool FileOkToWrite(String fileName)
    {
        return true;
    }

    public void KeepGeneratedFile(String name)
    {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name)
    {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter()
    {
        CurrentBlock = footer;
    }

    public void StartHeader()
    {
        CurrentBlock = header;
    }

    public void EndBlock()
    {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split)
    {
        if (split)
        {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (Block block in files)
            {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content)
    {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName)
    {
        return null;
    }

    public virtual String DefaultProjectNamespace
    {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent)
    {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template)
    {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock
    {
        get { return currentBlock; }
        set
        {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager
    {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;
        private IVsQueryEditQuerySave2 queryEditSave;

        public override String DefaultProjectNamespace
        {
            get
            {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName)
        {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split)
        {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        public override bool FileOkToWrite(String fileName)
        {
            CheckoutFileIfRequired(fileName);
            return base.FileOkToWrite(fileName);
        }

        protected override void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content))
            {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template)
        {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
            queryEditSave = (IVsQueryEditQuerySave2)hostServiceProvider.GetService(typeof(SVsQueryEditQuerySave));
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
        {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName)
        {
            if (queryEditSave != null)
            {
                uint pfEditVerdict;
                queryEditSave.QuerySaveFile(fileName, 0, null, out pfEditVerdict);
            }
            else
            {
                var sc = dte.SourceControl;
                if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName)) 
                    checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
            }
        }
    }
}

/*
    End of Manager.tt
*/
#>
